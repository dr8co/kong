// Package vm implements a stack-based virtual machine for executing bytecode instructions.
//
// This package provides a virtual machine that executes bytecode generated by the compiler.
// The [VM] uses a stack-based architecture with support for function calls, closures, local
// and global variables, control flow, arithmetic operations, and data structures (arrays and hashes).
//
// # Architecture
//
// The [VM] consists of several core components:
//
//   - Stack: A fixed-size array for operand storage and intermediate values
//   - Globals: A fixed-size array for global variable storage
//   - Frames: A call stack for managing function execution contexts
//   - Constants: A pool of immutable values (literals and compiled functions)
//
// # Execution Model
//
// The [VM] executes instructions sequentially using a fetch-decode-execute cycle:
//
//  1. Fetch the instruction at the current instruction pointer (ip)
//  2. Decode the opcode and extract any operands
//  3. Execute the operation (typically involving stack manipulation)
//  4. Advance the instruction pointer
//
// Instructions operate on a stack: operands are pushed onto the stack, operations pop
// their operands and push results, and the stack pointer (sp) tracks the top of the stack.
//
// # Function Calls and Closures
//
// The [VM] supports function calls through a frame-based call stack.
// Each frame contains:
//
//   - A closure (compiled function with captured free variables)
//   - An instruction pointer for the current position in the function
//   - A base pointer for accessing local variables and arguments
//
// Closures capture free variables from enclosing scopes, enabling proper lexical scoping
// and nested function support.
// The [VM] allocates space for local variables on the stack within each frame.
//
// # Constants and Limits
//
// The [VM] defines several constants that control resource limits:
//
//   - [StackSize]: Maximum stack depth (2048 elements)
//   - [GlobalsSize]: Maximum number of global variables (65536)
//   - [MaxFrames]: Maximum call stack depth (1024 frames)
//
// These limits prevent runaway programs from consuming excessive memory and help
// detect infinite recursion.
//
// # Built-in Values
//
// The [VM] pre-allocates singleton objects for commonly used values to reduce allocations:
//
//   - [True]: The boolean true value
//   - [False]: The boolean false value
//   - [Null]: The null/nil value
package vm

import (
	"fmt"

	"github.com/dr8co/kong/code"
	"github.com/dr8co/kong/compiler"
	"github.com/dr8co/kong/object"
)

const (
	// StackSize defines the maximum size of the stack used by the virtual machine.
	StackSize = 2048

	// GlobalsSize defines the maximum number of global variables available in the virtual machine.
	GlobalsSize = 65536

	// MaxFrames defines the maximum number of frames that can be used in the virtual machine's call stack.
	MaxFrames = 1024
)

var (
	// True is a predefined boolean object representing the value `true`.
	True = &object.Boolean{Value: true}

	// False is a predefined boolean object representing the value `false`.
	False = &object.Boolean{Value: false}

	// Null is a predefined object representing the `null` value. It indicates the absence of a meaningful value.
	Null = &object.Null{}
)

// VM represents a virtual machine used for executing bytecode and managing runtime state during program execution.
type VM struct {
	// Holds the compiled constants used during the bytecode execution in the virtual machine.
	constants []object.Object

	// stack holds the objects that make up the virtual machine's runtime evaluation stack.
	stack []object.Object

	// sp is the stack pointer, indicating the next available slot on the stack for a new object.
	sp int

	// globals stores global objects accessible across the virtual machine's context during execution.
	globals []object.Object

	// Holds the active frames for managing execution contexts in the virtual machine.
	frames []*Frame

	// framesIndex tracks the current active frame in the stack of execution frames for the virtual machine.
	framesIndex int
}

// makeFrames initializes a slice of frames with the main frame created from the provided bytecode.
func makeFrames(bytecode *compiler.Bytecode) []*Frame {
	mainFn := &object.CompiledFunction{Instructions: bytecode.Instructions}
	mainClosure := &object.Closure{Fn: mainFn}
	mainFrame := NewFrame(mainClosure, 0)
	frames := make([]*Frame, MaxFrames)
	frames[0] = mainFrame
	return frames
}

// New initializes and returns a new instance of the [VM] using the given bytecode.
func New(bytecode *compiler.Bytecode) *VM {
	frames := makeFrames(bytecode)

	return &VM{
		constants:   bytecode.Constants,
		stack:       make([]object.Object, StackSize),
		sp:          0,
		globals:     make([]object.Object, GlobalsSize),
		frames:      frames,
		framesIndex: 1,
	}
}

// NewWithGlobalsStore creates a new [VM] instance with the provided bytecode and a pre-allocated globals store.
func NewWithGlobalsStore(bytecode *compiler.Bytecode, s []object.Object) *VM {
	frames := makeFrames(bytecode)

	return &VM{
		constants:   bytecode.Constants,
		stack:       make([]object.Object, StackSize),
		sp:          0,
		globals:     s,
		frames:      frames,
		framesIndex: 1,
	}
}

// LastPoppedStackItem retrieves and returns the last item popped off the virtual machine's stack without modifying the stack.
func (vm *VM) LastPoppedStackItem() object.Object {
	return vm.stack[vm.sp]
}

// Run executes the instructions of the virtual machine, managing the program counter and stack during execution.
func (vm *VM) Run() error {
	var ip int
	var ins code.Instructions
	var op code.Opcode

	for vm.currentFrame().ip < len(vm.currentFrame().Instructions())-1 {
		vm.currentFrame().ip++
		ip = vm.currentFrame().ip
		ins = vm.currentFrame().Instructions()
		op = code.Opcode(ins[ip])

		switch op {
		case code.OpConstant:
			constIndex := code.ReadUint16(ins[ip+1:])
			vm.currentFrame().ip += 2
			err := vm.push(vm.constants[constIndex])
			if err != nil {
				return err
			}

		case code.OpAdd, code.OpSub, code.OpMul, code.OpDiv:
			err := vm.executeBinaryOperation(op)
			if err != nil {
				return err
			}

		case code.OpEqual, code.OpNotEqual, code.OpGreaterThan:
			err := vm.executeComparison(op)
			if err != nil {
				return err
			}

		case code.OpPop:
			vm.pop()

		case code.OpTrue:
			err := vm.push(True)
			if err != nil {
				return err
			}

		case code.OpFalse:
			err := vm.push(False)
			if err != nil {
				return err
			}

		case code.OpBang:
			err := vm.executeBangOperator()
			if err != nil {
				return err
			}

		case code.OpMinus:
			err := vm.executeMinusOperator()
			if err != nil {
				return err
			}

		case code.OpJump:
			pos := int(code.ReadUint16(ins[ip+1:]))
			vm.currentFrame().ip = pos - 1

		case code.OpJumpNotTruthy:
			pos := int(code.ReadUint16(ins[ip+1:]))
			vm.currentFrame().ip += 2

			condition := vm.pop()
			if !isTruthy(condition) {
				vm.currentFrame().ip = pos - 1
			}

		case code.OpNull:
			err := vm.push(Null)
			if err != nil {
				return err
			}

		case code.OpSetGlobal:
			globalIndex := code.ReadUint16(ins[ip+1:])
			vm.currentFrame().ip += 2
			vm.globals[globalIndex] = vm.pop()

		case code.OpGetGlobal:
			globalIndex := code.ReadUint16(ins[ip+1:])
			vm.currentFrame().ip += 2

			err := vm.push(vm.globals[globalIndex])
			if err != nil {
				return err
			}

		case code.OpArray:
			numElements := int(code.ReadUint16(ins[ip+1:]))
			vm.currentFrame().ip += 2
			array := vm.buildArray(vm.sp-numElements, vm.sp)
			vm.sp -= numElements

			err := vm.push(array)
			if err != nil {
				return err
			}

		case code.OpHash:
			numElements := int(code.ReadUint16(ins[ip+1:]))
			vm.currentFrame().ip += 2

			hash, err := vm.buildHash(vm.sp-numElements, vm.sp)
			if err != nil {
				return err
			}
			vm.sp = vm.sp - numElements

			err = vm.push(hash)
			if err != nil {
				return err
			}

		case code.OpIndex:
			index := vm.pop()
			left := vm.pop()

			err := vm.executeIndexExpression(left, index)
			if err != nil {
				return err
			}

		case code.OpReturn:
			frame := vm.popFrame()
			vm.sp = frame.basePointer - 1

			err := vm.push(Null)
			if err != nil {
				return err
			}

		case code.OpReturnValue:
			returnValue := vm.pop()
			frame := vm.popFrame()
			vm.sp = frame.basePointer - 1

			err := vm.push(returnValue)
			if err != nil {
				return err
			}

		case code.OpCall:
			numArgs := int(code.ReadUint8(ins[ip+1:]))
			vm.currentFrame().ip += 1

			err := vm.executeCall(numArgs)
			if err != nil {
				return err
			}

		case code.OpSetLocal:
			localIndex := code.ReadUint8(ins[ip+1:])
			vm.currentFrame().ip += 1
			frame := vm.currentFrame()
			vm.stack[frame.basePointer+int(localIndex)] = vm.pop()

		case code.OpGetLocal:
			localIndex := code.ReadUint8(ins[ip+1:])
			vm.currentFrame().ip += 1
			frame := vm.currentFrame()

			err := vm.push(vm.stack[frame.basePointer+int(localIndex)])
			if err != nil {
				return err
			}

		case code.OpGetBuiltin:
			builtinIndex := code.ReadUint8(ins[ip+1:])
			vm.currentFrame().ip += 1

			definition := object.Builtins[builtinIndex]
			err := vm.push(definition.Builtin)
			if err != nil {
				return err
			}

		case code.OpClosure:
			constIndex := int(code.ReadUint16(ins[ip+1:]))
			numFree := int(code.ReadUint8(ins[ip+3:]))
			vm.currentFrame().ip += 3

			err := vm.pushClosure(constIndex, numFree)
			if err != nil {
				return err
			}

		case code.OpGetFree:
			freeIndex := int(code.ReadUint8(ins[ip+1:]))
			vm.currentFrame().ip += 1
			currentClosure := vm.currentFrame().cl

			err := vm.push(currentClosure.Free[freeIndex])
			if err != nil {
				return err
			}

		case code.OpCurrentClosure:
			currentClosure := vm.currentFrame().cl
			err := vm.push(currentClosure)
			if err != nil {
				return err
			}
		}
	}
	return nil
}

// isTruthy determines the truthiness of an object based on its type and value.
//
// Returns true for non-null, non-boolean false objects, and false otherwise.
func isTruthy(obj object.Object) bool {
	switch obj := obj.(type) {
	case *object.Boolean:
		return obj.Value
	case *object.Null:
		return false
	default:
		return true
	}
}

// push adds an object to the stack of the virtual machine and increments the stack pointer.
// Returns an error on overflow.
func (vm *VM) push(obj object.Object) error {
	if vm.sp >= StackSize {
		return fmt.Errorf("stack overflow")
	}
	vm.stack[vm.sp] = obj
	vm.sp++
	return nil
}

// pop removes and returns the top object from the stack, while decrementing the stack pointer by one.
func (vm *VM) pop() object.Object {
	obj := vm.stack[vm.sp-1]
	vm.sp--
	return obj
}

// executeBinaryOperation performs a binary operation based on the provided opcode on two values popped from the stack.
//
// Returns an error if the operation is not supported for the operand types.
func (vm *VM) executeBinaryOperation(op code.Opcode) error {
	right := vm.pop()
	left := vm.pop()

	rightType := right.Type()
	leftType := left.Type()

	switch {
	case leftType == object.INTEGER_OBJ && rightType == object.INTEGER_OBJ:
		return vm.executeBinaryIntegerOperation(op, left, right)
	case leftType == object.STRING_OBJ && rightType == object.STRING_OBJ:
		return vm.executeBinaryStringOperation(op, left, right)
	default:
		return fmt.Errorf("unsupported types for binary operation: %s %s", leftType, rightType)
	}
}

// executeBinaryIntegerOperation performs a binary operation on two integer objects based on the given opcode.
func (vm *VM) executeBinaryIntegerOperation(op code.Opcode, left, right object.Object) error {
	leftVal := left.(*object.Integer).Value
	rightVal := right.(*object.Integer).Value

	var result int64

	switch op {
	case code.OpAdd:
		result = leftVal + rightVal
	case code.OpSub:
		result = leftVal - rightVal
	case code.OpMul:
		result = leftVal * rightVal
	case code.OpDiv:
		result = leftVal / rightVal
	default:
		return fmt.Errorf("unknown integer operator: %d", op)
	}

	return vm.push(&object.Integer{Value: result})
}

// executeBinaryStringOperation performs binary string operations,
// currently supporting only addition (concatenation) of strings.
func (vm *VM) executeBinaryStringOperation(op code.Opcode, left, right object.Object) error {
	if op != code.OpAdd {
		return fmt.Errorf("unknown string operator: %d", op)
	}
	leftValue := left.(*object.String).Value
	rightValue := right.(*object.String).Value

	return vm.push(&object.String{Value: leftValue + rightValue})
}

// executeComparison evaluates a comparison operation between two operands and pushes the result onto the stack.
//
// Returns an error if an unknown operator is encountered or execution fails.
func (vm *VM) executeComparison(op code.Opcode) error {
	right := vm.pop()
	left := vm.pop()

	if left.Type() == object.INTEGER_OBJ && right.Type() == object.INTEGER_OBJ {
		return vm.executeIntegerComparison(op, left, right)
	}

	switch op {
	case code.OpEqual:
		return vm.push(nativeBoolToBooleanObject(right == left))
	case code.OpNotEqual:
		return vm.push(nativeBoolToBooleanObject(right != left))
	default:
		return fmt.Errorf("unknown operator: %d (%s %s)", op, left.Type(), right.Type())
	}
}

// nativeBoolToBooleanObject converts a native Go boolean to a corresponding predefined Boolean object
// (`True` or `False`).
func nativeBoolToBooleanObject(input bool) *object.Boolean {
	if input {
		return True
	}
	return False
}

// executeIntegerComparison evaluates a comparison operation between two integer objects and pushes the result onto the stack.
//
// Returns an error if the operation is invalid or if an unknown opcode is provided.
func (vm *VM) executeIntegerComparison(op code.Opcode, left, right object.Object) error {
	leftValue := left.(*object.Integer).Value
	rightValue := right.(*object.Integer).Value

	switch op {
	case code.OpEqual:
		return vm.push(nativeBoolToBooleanObject(rightValue == leftValue))
	case code.OpNotEqual:
		return vm.push(nativeBoolToBooleanObject(rightValue != leftValue))
	case code.OpGreaterThan:
		return vm.push(nativeBoolToBooleanObject(leftValue > rightValue))
	default:
		return fmt.Errorf("unknown operator: %d", op)
	}
}

// executeBangOperator evaluates the bang operator (!)
// by negating a boolean or null operand and pushing the result back onto the stack.
func (vm *VM) executeBangOperator() error {
	operand := vm.pop()

	switch operand {
	case True:
		return vm.push(False)
	case False:
		return vm.push(True)
	case Null:
		return vm.push(True)
	default:
		return vm.push(False)
	}
}

// executeMinusOperator negates the integer value at the top of the VM stack and pushes the result back onto the stack.
func (vm *VM) executeMinusOperator() error {
	operand := vm.pop()

	if operand.Type() != object.INTEGER_OBJ {
		return fmt.Errorf("unsupported type for negation: %s", operand.Type())
	}
	value := operand.(*object.Integer).Value
	return vm.push(&object.Integer{Value: -value})
}

// buildArray creates a new array object from the VM's stack within the specified startIndex and endIndex range.
func (vm *VM) buildArray(startIndex, endIndex int) object.Object {
	elements := make([]object.Object, endIndex-startIndex)

	for i := startIndex; i < endIndex; i++ {
		elements[i-startIndex] = vm.stack[i]
	}

	return &object.Array{Elements: elements}
}

// buildHash constructs a hash object from stack elements between startIndex and endIndex,
// treating pairs as key-value entries.
//
// Returns a hash object or an error if a key is not hashable.
func (vm *VM) buildHash(startIndex, endIndex int) (object.Object, error) {
	hashedPairs := make(map[object.HashKey]object.HashPair)

	for i := startIndex; i < endIndex; i += 2 {
		key := vm.stack[i]
		value := vm.stack[i+1]
		pair := object.HashPair{Key: key, Value: value}

		hashKey, ok := key.(object.Hashable)
		if !ok {
			return nil, fmt.Errorf("unusable as hash key: %s", key.Type())
		}

		hashedPairs[hashKey.HashKey()] = pair
	}

	return &object.Hash{Pairs: hashedPairs}, nil
}

// executeIndexExpression processes index expressions on supported types like arrays and hashes within the VM.
func (vm *VM) executeIndexExpression(left, index object.Object) error {
	switch {
	case left.Type() == object.ARRAY_OBJ && index.Type() == object.INTEGER_OBJ:
		return vm.executeArrayIndex(left, index)
	case left.Type() == object.HASH_OBJ:
		return vm.executeHashIndex(left, index)
	default:
		return fmt.Errorf("index operator not supported: %s", left.Type())
	}
}

// executeArrayIndex retrieves the element at the given index from the array and pushes it onto the stack or null if out of bounds.
func (vm *VM) executeArrayIndex(array, index object.Object) error {
	arrayObject := array.(*object.Array)
	i := index.(*object.Integer).Value

	maxElems := int64(len(arrayObject.Elements) - 1)
	if i < 0 || i > maxElems {
		return vm.push(Null)
	}

	return vm.push(arrayObject.Elements[i])
}

// executeHashIndex retrieves a value from a hash using a hashable key and pushes it onto the stack.
//
// Returns an error if the key is not hashable or if value retrieval fails.
func (vm *VM) executeHashIndex(hash, index object.Object) error {
	hashObject := hash.(*object.Hash)
	key, ok := index.(object.Hashable)
	if !ok {
		return fmt.Errorf("unusable as hash key: %s", index.Type())
	}

	pair, ok := hashObject.Pairs[key.HashKey()]
	if !ok {
		return vm.push(Null)
	}

	return vm.push(pair.Value)
}

// currentFrame returns the current active frame from the VM's stack of frames.
func (vm *VM) currentFrame() *Frame {
	return vm.frames[vm.framesIndex-1]
}

// pushFrame adds a new frame to the VM's stack and increments the stack index.
func (vm *VM) pushFrame(frame *Frame) {
	vm.frames[vm.framesIndex] = frame
	vm.framesIndex++
}

// popFrame removes the top frame from the VM's call stack and returns it.
func (vm *VM) popFrame() *Frame {
	vm.framesIndex--
	return vm.frames[vm.framesIndex]
}

// callClosure executes a given Closure object by creating a new frame and adjusting the stack pointer accordingly.
//
// Returns an error if the number of arguments does not match the expected count.
func (vm *VM) callClosure(cl *object.Closure, numArgs int) error {
	if numArgs != cl.Fn.NumParameters {
		return fmt.Errorf("wrong number of arguments: want=%d, got=%d", cl.Fn.NumParameters, numArgs)
	}

	frame := NewFrame(cl, vm.sp-numArgs)
	vm.pushFrame(frame)
	vm.sp = frame.basePointer + cl.Fn.NumLocals

	return nil
}

// executeCall executes a function call by determining the callee type and invoking the corresponding execution logic.
// It handles closures and built-in functions, returning an error if the callee is not callable.
//
// numArgs specifies the number of arguments passed to the function.
func (vm *VM) executeCall(numArgs int) error {
	callee := vm.stack[vm.sp-1-numArgs]

	switch callee := callee.(type) {
	case *object.Closure:
		return vm.callClosure(callee, numArgs)
	case *object.Builtin:
		return vm.callBuiltin(callee, numArgs)
	default:
		return fmt.Errorf("calling non-function and non-built-in")
	}
}

// callBuiltin invokes a builtin function with the provided arguments and handles the [VM.stack] manipulation for the result.
func (vm *VM) callBuiltin(builtin *object.Builtin, numArgs int) error {
	args := vm.stack[vm.sp-numArgs : vm.sp]

	result := builtin.Fn(args...)
	vm.sp = vm.sp - numArgs - 1

	var err error
	if result != nil {
		err = vm.push(result)
	} else {
		err = vm.push(Null)
	}

	return err
}

// pushClosure creates a closure from a compiled function and its free variables, then pushes it onto the [VM.stack].
func (vm *VM) pushClosure(constIndex, numFree int) error {
	constObj := vm.constants[constIndex]
	function, ok := constObj.(*object.CompiledFunction)
	if !ok {
		return fmt.Errorf("not a function: %+v", constObj)
	}
	free := make([]object.Object, numFree)
	for i := 0; i < numFree; i++ {
		free[i] = vm.stack[vm.sp-numFree+i]
	}
	vm.sp = vm.sp - numFree

	closure := &object.Closure{Fn: function, Free: free}
	return vm.push(closure)
}
